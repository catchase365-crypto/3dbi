<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>S Pen 3D 对称大师版 v3.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; touch-action: none; font-family: 'Segoe UI', sans-serif; user-select: none; transition: background-color 0.5s; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* 左侧笔刷库 */
        .brush-panel {
            position: absolute; top: 50%; left: 20px; transform: translateY(-50%);
            background: var(--panel-bg, rgba(20, 20, 20, 0.85)); backdrop-filter: blur(15px);
            border: 1px solid var(--border-color, rgba(255, 255, 255, 0.1)); border-radius: 16px; padding: 10px;
            display: flex; flex-direction: column; gap: 12px; max-height: 70vh; overflow-y: auto; z-index: 20;
            scrollbar-width: none;
        }
        .brush-panel::-webkit-scrollbar { display: none; }
        .brush-item {
            width: 44px; height: 44px; border-radius: 12px; cursor: pointer; position: relative;
            border: 2px solid transparent; transition: all 0.2s; display: flex; align-items: center; justify-content: center;
            background: var(--btn-bg, rgba(255,255,255,0.05));
        }
        .brush-item.active { border-color: #3b82f6; background: rgba(59, 130, 246, 0.2); box-shadow: 0 0 15px rgba(59, 130, 246, 0.3); }
        .brush-icon { width: 24px; height: 24px; border-radius: 50%; }
        
        /* 笔刷图标 */
        .icon-solid { background: #888; border-radius: 20px; width: 30px; height: 6px; box-shadow: 0 0 2px #888; }
        .icon-neon { background: #00ffcc; box-shadow: 0 0 5px #00ffcc; }
        .icon-metal { background: linear-gradient(135deg, #ddd, #555); }
        .icon-crystal { border: 1px solid #888; transform: rotate(45deg); }
        .icon-pixel { background: #ff3366; clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); }
        .icon-bubble { border: 2px solid #0099ff; }
        .icon-ribbon { width: 26px; height: 8px; background: #ffff00; }
        .icon-star { background: #ff9900; clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); }

        /* 右侧功能区 */
        .top-right-ui { position: absolute; top: 20px; right: 20px; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; z-index: 20; }
        .current-color-btn { width: 48px; height: 48px; border-radius: 50%; border: 3px solid rgba(128,128,128,0.5); cursor: pointer; box-shadow: 0 0 10px rgba(0,0,0,0.2); }
        
        .toggle-btn {
            background: var(--panel-bg, rgba(0,0,0,0.6)); backdrop-filter: blur(10px); color: var(--text-color, #aaa); padding: 8px 12px;
            border-radius: 20px; border: 1px solid var(--border-color, rgba(255,255,255,0.1)); font-size: 13px; cursor: pointer;
            display: flex; align-items: center; gap: 8px; transition: all 0.3s;
        }
        .toggle-btn:hover { transform: translateX(-5px); }
        .toggle-btn.active { border-color: #00ffcc; color: #00ffcc; background: rgba(0, 255, 204, 0.1); }
        .led { width: 6px; height: 6px; background: #555; border-radius: 50%; }
        .toggle-btn.active .led { background: #00ffcc; box-shadow: 0 0 5px #00ffcc; }

        /* 对称按钮组 */
        .sym-group {
            display: flex; flex-direction: column; gap: 5px;
            background: rgba(30,30,30,0.5); padding: 8px; border-radius: 16px; border: 1px solid rgba(255,255,255,0.05);
        }
        .sym-title { color: #666; font-size: 10px; text-align: center; margin-bottom: 2px; }
        .sym-btn {
            width: 100%; justify-content: space-between; padding: 6px 12px;
        }
        .sym-icon { font-weight: bold; font-family: monospace; font-size: 14px; }

        /* 颜色槽 */
        .color-slots-container { display: flex; flex-direction: column; gap: 8px; background: var(--panel-bg, rgba(20,20,20,0.6)); padding: 8px; border-radius: 20px; backdrop-filter: blur(5px); border: 1px solid var(--border-color, rgba(255,255,255,0.05)); }
        .color-slot { width: 32px; height: 32px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; }
        .color-slot.active { border-color: var(--text-color, white); transform: scale(1.1); }

        /* 底部工具栏 */
        .toolbar-container {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center; gap: 10px; z-index: 20;
        }

        .size-slider-box {
            background: var(--panel-bg, rgba(0,0,0,0.6)); backdrop-filter: blur(10px); padding: 5px 15px; border-radius: 20px;
            display: flex; align-items: center; gap: 10px; border: 1px solid var(--border-color, rgba(255,255,255,0.1));
        }
        .size-slider-box span { color: var(--text-color, #aaa); font-size: 12px; }
        input[type=range] { width: 150px; accent-color: #3b82f6; cursor: pointer; }

        .toolbar { display: flex; gap: 12px; padding: 10px; background: var(--panel-bg, rgba(0,0,0,0.5)); border-radius: 30px; backdrop-filter: blur(10px); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .btn {
            width: 48px; height: 48px; border-radius: 50%; background: var(--btn-bg, rgba(60,60,60,0.9));
            border: 1px solid var(--border-color, rgba(255,255,255,0.2)); color: var(--text-color, white); display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .btn:active { transform: scale(0.9); }
        .btn.mode-active { background: #ff3366; border-color: #ff99aa; color: white; } 
        .btn.roam-active { background: #3388ff; border-color: #88ccff; color: white; }

        /* 虚拟摇杆与提示 */
        #joystick-zone { position: absolute; bottom: 120px; left: 40px; width: 120px; height: 120px; z-index: 30; display: none; }
        #roam-hint { position: absolute; top: 100px; width: 100%; text-align: center; color: var(--text-color, rgba(255,255,255,0.5)); pointer-events: none; display: none; }

        /* 100色面板 */
        .color-grid-modal {
            position: absolute; top: 20px; right: 80px; background: var(--panel-bg, rgba(30,30,30,0.95)); backdrop-filter: blur(20px);
            padding: 10px; border-radius: 12px; border: 1px solid var(--border-color, rgba(255,255,255,0.1)); display: none;
            grid-template-columns: repeat(10, 1fr); gap: 4px; z-index: 30; width: 280px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .color-cell { width: 100%; aspect-ratio: 1; border-radius: 3px; cursor: pointer; border: 1px solid rgba(128,128,128,0.2); }

        #snap-reticle { position: absolute; width: 30px; height: 30px; border: 2px solid #ff3333; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 50; }
        #toast { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 8px; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 60; }
        #file-input { display: none; }

        /* CSS 变量：日夜模式 */
        body.light-mode {
            --panel-bg: rgba(240, 240, 240, 0.85);
            --btn-bg: rgba(255, 255, 255, 0.9);
            --border-color: rgba(0, 0, 0, 0.1);
            --text-color: #333;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="snap-reticle"></div>
    <div id="toast">提示信息</div>
    <div id="joystick-zone"></div>
    <div id="roam-hint">漫游模式：左侧摇杆移动，单指转动视角</div>
    <input type="file" id="file-input" accept=".json" onchange="loadProjectFile(this)">

    <!-- 左侧笔刷 -->
    <div class="brush-panel" id="brush-panel">
        <div class="brush-item active" onclick="setBrush(100)" title="连贯速写笔"><div class="brush-icon icon-solid"></div></div>
        <div class="brush-item" onclick="setBrush(0)" title="霓虹灯"><div class="brush-icon icon-neon"></div></div>
        <div class="brush-item" onclick="setBrush(1)" title="液态金属"><div class="brush-icon icon-metal"></div></div>
        <div class="brush-item" onclick="setBrush(2)" title="悬浮水晶"><div class="brush-icon icon-crystal"></div></div>
        <div class="brush-item" onclick="setBrush(3)" title="赛博像素"><div class="brush-icon icon-pixel"></div></div>
        <div class="brush-item" onclick="setBrush(4)" title="量子气泡"><div class="brush-icon icon-bubble"></div></div>
        <div class="brush-item" onclick="setBrush(5)" title="光带"><div class="brush-icon icon-ribbon"></div></div>
        <div class="brush-item" onclick="setBrush(6)" title="星尘"><div class="brush-icon icon-star"></div></div>
    </div>

    <!-- 右侧功能 -->
    <div class="top-right-ui">
        <div class="current-color-btn" id="main-color-btn" onclick="toggleColorGrid()"></div>
        <div class="color-grid-modal" id="color-grid"></div>
        
        <button class="toggle-btn" id="bg-btn" onclick="toggleBackground()" title="日夜模式">
            <svg id="icon-moon" style="display:block" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            <svg id="icon-sun" style="display:none" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
        </button>

        <button class="toggle-btn" id="vplane-btn" onclick="toggleVerticalPlanes()">
            <div class="led"></div><span>象限参考</span>
        </button>

        <button class="toggle-btn" id="anchor-btn" onclick="toggleAnchor()">
            <div class="led"></div><span>锚定吸附</span>
        </button>

        <!-- 强化的对称按钮组 -->
        <div class="sym-group">
            <div class="sym-title">对称系统</div>
            <button class="toggle-btn sym-btn" id="sym-x" onclick="setSymmetry('X')" title="左右对称 (2笔)">
                <span>X轴</span><span class="sym-icon">|</span>
            </button>
            <button class="toggle-btn sym-btn" id="sym-z" onclick="setSymmetry('Z')" title="前后对称 (2笔)">
                <span>Z轴</span><span class="sym-icon">/</span>
            </button>
            <button class="toggle-btn sym-btn" id="sym-4" onclick="setSymmetry('QUAD')" title="四象限对称 (4笔)">
                <span>四象</span><span class="sym-icon">+</span>
            </button>
            <button class="toggle-btn sym-btn" id="sym-8" onclick="setSymmetry('OCTO')" title="八象限全开 (8笔)">
                <span>八象</span><span class="sym-icon">✴</span>
            </button>
        </div>

        <div class="color-slots-container">
            <div class="color-slot" id="slot-0" onclick="selectSlot(0)"></div>
            <div class="color-slot" id="slot-1" onclick="selectSlot(1)"></div>
            <div class="color-slot" id="slot-2" onclick="selectSlot(2)"></div>
            <div class="color-slot" id="slot-3" onclick="selectSlot(3)"></div>
            <div class="color-slot" id="slot-4" onclick="selectSlot(4)"></div>
        </div>
    </div>

    <!-- 底部工具栏 -->
    <div class="toolbar-container">
        <div class="size-slider-box">
            <span>粗细</span>
            <input type="range" id="size-slider" min="1" max="50" value="10">
            <span id="size-val">1.0</span>
        </div>

        <div class="toolbar">
            <button class="btn" onclick="undo()" title="撤销">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></svg>
            </button>
            <button class="btn" onclick="redo()" title="重做">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 14l5-5-5-5"/><path d="M20 9H9.5A5.5 5.5 0 0 0 4 14.5v0A5.5 5.5 0 0 0 9.5 20H13"/></svg>
            </button>
            <div style="width: 1px; background: rgba(128,128,128,0.3); margin: 0 2px;"></div>
            <button class="btn" id="eraser-btn" onclick="toggleEraser()" title="3D 橡皮擦">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16C2 15 2 13 3 12L13 2L22 11L20 20Z"></path><line x1="10" y1="10" x2="20" y2="20"></line></svg>
            </button>
            <button class="btn" id="roam-btn" onclick="toggleRoam()" title="漫游飞行模式">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg>
            </button>
            <div style="width: 1px; background: rgba(128,128,128,0.3); margin: 0 2px;"></div>
            <button class="btn" onclick="saveProject()" title="保存工程">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
            </button>
            <button class="btn" onclick="triggerLoad()" title="读取工程">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>
            </button>
            <button class="btn" onclick="saveImage()" title="拍摄照片">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3.2"></circle><path d="M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"></path></svg>
            </button>
            <button class="btn" onclick="clearScene()" title="清空" style="color: #ff6666;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
            </button>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let joystickManager = null;
        let isDrawing = false, isEraser = false, isRoam = false;
        let isAnchorMode = false;
        let symmetryMode = 'NONE'; // 'NONE', 'X', 'Z', 'QUAD', 'OCTO'
        let isDarkMode = true; 
        let isVerticalGridVisible = false;

        let currentBrushIndex = 100; 
        let baseBrushSize = 1.0; 
        
        let moveVector = new THREE.Vector3(0, 0, 0); 
        let cameraEuler = new THREE.Euler(0, 0, 0, 'YXZ');
        
        let activeSlotIndex = 0;
        let slotColors = ['#ffffff', '#00ffcc', '#ff3366', '#ffff00', '#3b82f6'];
        let currentColor = new THREE.Color(slotColors[0]);
        let strokes = [], redoStack = [], currentStrokeGroup = null, lastPoint = new THREE.Vector3();
        let lastPressure = 0.5;

        const drawPlane = new THREE.Plane(), raycaster = new THREE.Raycaster(), pointer = new THREE.Vector2();
        let gridXZ, gridXY, gridYZ;

        const geoms = {
            sphere: new THREE.SphereGeometry(1, 8, 8),
            box: new THREE.BoxGeometry(1, 1, 1),
            diamond: new THREE.OctahedronGeometry(1, 0),
            flat: new THREE.CylinderGeometry(1, 1, 0.2, 6),
            star: new THREE.IcosahedronGeometry(1, 0)
        };
        geoms.flat.rotateX(Math.PI/2);
        
        const cylinderGeo = new THREE.CylinderGeometry(0.5, 0.5, 1, 6);
        cylinderGeo.translate(0, 0.5, 0); 
        cylinderGeo.rotateX(Math.PI / 2); 

        init(); initColorGrid(); initSlots(); initSlider(); animate();

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); 
            scene.background = new THREE.Color(0x050505); 
            scene.fog = new THREE.FogExp2(0x050505, 0.015);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.set(20, 20, 30); camera.lookAt(0,0,0);
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight); renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);
            initGrids(true);
            scene.add(new THREE.AmbientLight(0x404040, 1));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1); dirLight.position.set(10, 20, 10); scene.add(dirLight);
            camera.add(new THREE.PointLight(0xffffff, 0.6)); scene.add(camera);
            controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.rotateSpeed = 0.6;
            container.addEventListener('pointerdown', onPointerDown, { passive: false, capture: true });
            container.addEventListener('pointermove', onPointerMove, { passive: false });
            container.addEventListener('pointerup', onPointerUp, { passive: false });
            window.addEventListener('resize', onWindowResize); window.addEventListener('contextmenu', e => e.preventDefault());
        }

        function initGrids(isDark) {
            if (gridXZ) scene.remove(gridXZ); if (gridXY) scene.remove(gridXY); if (gridYZ) scene.remove(gridYZ);
            const c1 = isDark ? 0x888888 : 0x444444; const c2 = isDark ? 0x222222 : 0xdddddd;
            gridXZ = new THREE.GridHelper(50, 50, c1, c2); scene.add(gridXZ);
            gridXY = new THREE.GridHelper(50, 50, c1, c2); gridXY.rotation.x = Math.PI / 2; gridXY.visible = isVerticalGridVisible; scene.add(gridXY);
            gridYZ = new THREE.GridHelper(50, 50, c1, c2); gridYZ.rotation.z = Math.PI / 2; gridYZ.visible = isVerticalGridVisible; scene.add(gridYZ);
        }

        // --- 对称系统 (Symmetry System) ---
        function setSymmetry(mode) {
            if (symmetryMode === mode) {
                // 如果再次点击，取消对称
                symmetryMode = 'NONE';
                showToast("对称关闭");
            } else {
                symmetryMode = mode;
                let msg = "";
                if(mode==='X') msg = "X轴左右对称 (2笔)";
                if(mode==='Z') msg = "Z轴前后对称 (2笔)";
                if(mode==='QUAD') msg = "四象限对称 (4笔)";
                if(mode==='OCTO') msg = "八象限全开 (8笔)";
                showToast(msg);
            }
            updateSymmetryUI();
        }

        function updateSymmetryUI() {
            document.getElementById('sym-x').classList.toggle('active', symmetryMode === 'X');
            document.getElementById('sym-z').classList.toggle('active', symmetryMode === 'Z');
            document.getElementById('sym-4').classList.toggle('active', symmetryMode === 'QUAD');
            document.getElementById('sym-8').classList.toggle('active', symmetryMode === 'OCTO');
        }

        // 核心：计算对称点集
        function getSymmetryPoints(p) {
            const points = [p.clone()]; // 原始点
            
            if (symmetryMode === 'X') {
                points.push(new THREE.Vector3(-p.x, p.y, p.z));
            } else if (symmetryMode === 'Z') {
                points.push(new THREE.Vector3(p.x, p.y, -p.z));
            } else if (symmetryMode === 'QUAD') {
                // 四象限 (X & Z)
                points.push(new THREE.Vector3(-p.x, p.y, p.z));
                points.push(new THREE.Vector3(p.x, p.y, -p.z));
                points.push(new THREE.Vector3(-p.x, p.y, -p.z));
            } else if (symmetryMode === 'OCTO') {
                // 八象限 (X & Z & Y)
                // 先生成水平四点
                const level1 = [
                    new THREE.Vector3(p.x, p.y, p.z),
                    new THREE.Vector3(-p.x, p.y, p.z),
                    new THREE.Vector3(p.x, p.y, -p.z),
                    new THREE.Vector3(-p.x, p.y, -p.z)
                ];
                // 再生成下方镜像四点
                level1.forEach(kp => {
                    // 如果不是原始点，已经push进去了，这里逻辑稍微调整下
                    // 直接重构 points 列表更干净
                });
                // 重置 points，因为逻辑复杂
                return [
                    new THREE.Vector3(p.x, p.y, p.z),
                    new THREE.Vector3(-p.x, p.y, p.z),
                    new THREE.Vector3(p.x, p.y, -p.z),
                    new THREE.Vector3(-p.x, p.y, -p.z),
                    new THREE.Vector3(p.x, -p.y, p.z),
                    new THREE.Vector3(-p.x, -p.y, p.z),
                    new THREE.Vector3(p.x, -p.y, -p.z),
                    new THREE.Vector3(-p.x, -p.y, -p.z)
                ];
            }
            return points;
        }

        // --- 绘图逻辑 ---
        function onPointerDown(e) {
            if (isRoam) { isDrawing = true; lastPoint.x = e.clientX; lastPoint.y = e.clientY; return; }
            if (isEraser) { handleEraser(e); return; }
            if(e.pointerType==='pen' || e.pointerType==='mouse'){ 
                isDrawing=true; controls.enabled=false; e.stopPropagation(); redoStack=[]; determineDrawPlane(e);
                currentStrokeGroup=new THREE.Group(); currentStrokeGroup.userData = { brushIndex: currentBrushIndex, color: '#' + currentColor.getHexString() };
                scene.add(currentStrokeGroup);
                const pos=getDrawPoint(e); 
                if(pos){ 
                    lastPressure = e.pressure || 0.5; 
                    // 应用对称
                    const symPoints = getSymmetryPoints(pos);
                    symPoints.forEach(sp => addMesh(sp, lastPressure, true));
                    lastPoint.copy(pos); 
                }
            } else { isDrawing=false; controls.enabled=true; }
        }

        function onPointerMove(e) {
            if (isRoam && isDrawing) {
                const dx = e.clientX - lastPoint.x; const dy = e.clientY - lastPoint.y; lastPoint.x = e.clientX; lastPoint.y = e.clientY;
                cameraEuler.y -= dx * 0.005; cameraEuler.x -= dy * 0.005; cameraEuler.x = Math.max(-1.5, Math.min(1.5, cameraEuler.x)); camera.quaternion.setFromEuler(cameraEuler); return;
            }
            if (isEraser && e.buttons>0) { handleEraser(e); return; }
            if(isDrawing && (e.pointerType==='pen' || e.pointerType==='mouse')){
                e.preventDefault(); const p=getDrawPoint(e); if(!p)return; const d=p.distanceTo(lastPoint); const cp = e.pressure || 0.5;
                
                // 对称处理：计算原始两点，然后生成它们的对称点对
                if (currentBrushIndex === 100) {
                    if (d > 0.05) { 
                        const symStarts = getSymmetryPoints(lastPoint);
                        const symEnds = getSymmetryPoints(p);
                        
                        // 假设 symStarts 和 symEnds 顺序是一致的 (getSymmetryPoints 算法保证)
                        for(let i=0; i<symStarts.length; i++) {
                            addCylinderConnection(symStarts[i], symEnds[i], lastPressure, cp);
                        }
                        
                        lastPoint.copy(p); lastPressure = cp; 
                    }
                } else {
                    if(d>0.3) { 
                        const c = Math.floor(d/0.3); 
                        for(let i=1;i<=c;i++) { 
                            const lp = new THREE.Vector3().copy(lastPoint).lerp(p,i/c); 
                            const symLPs = getSymmetryPoints(lp);
                            symLPs.forEach(slp => addMesh(slp, cp));
                        } 
                    }
                    const symPs = getSymmetryPoints(p);
                    symPs.forEach(sp => addMesh(sp, cp));
                    lastPoint.copy(p);
                }
            }
        }

        // --- 画笔核心 ---
        function addCylinderConnection(s, e, p1, p2) {
            if (!currentStrokeGroup) return; const dist = s.distanceTo(e); const t = baseBrushSize * (0.2 + (p1+p2)*0.2); 
            const mat = new THREE.MeshLambertMaterial({ color: currentColor });
            const cyl = new THREE.Mesh(cylinderGeo, mat); cyl.position.copy(s); cyl.lookAt(e); cyl.scale.set(t, t, dist); currentStrokeGroup.add(cyl);
            const sph = new THREE.Mesh(geoms.sphere, mat); sph.position.copy(e); const ss = t * 0.55; sph.scale.set(ss, ss, ss); currentStrokeGroup.add(sph);
        }
        function addMesh(pos, pres, cap=false) { if(!currentStrokeGroup)return; if(currentBrushIndex===100||cap){ const t=baseBrushSize*(0.2+pres*0.4); const m=new THREE.Mesh(geoms.sphere, new THREE.MeshLambertMaterial({color:currentColor})); m.position.copy(pos); const s=t*0.55; m.scale.set(s,s,s); currentStrokeGroup.add(m); return; } let s=baseBrushSize*(0.15+(pres*0.25)); if(currentBrushIndex==5)s=baseBrushSize*(0.3+(pres*0.25)); const m=new THREE.Mesh(getBrushGeometry(currentBrushIndex), getBrushMaterial(currentBrushIndex,currentColor)); m.position.copy(pos); m.scale.set(s,s,s); if([1,2,6].includes(currentBrushIndex)) m.rotation.set(Math.random()*3,Math.random()*3,Math.random()*3); if(currentBrushIndex==5) m.lookAt(camera.position); currentStrokeGroup.add(m); }

        // --- UI & Utils ---
        function toggleBackground() { isDarkMode = !isDarkMode; document.getElementById('icon-moon').style.display = isDarkMode ? 'block' : 'none'; document.getElementById('icon-sun').style.display = isDarkMode ? 'none' : 'block'; document.body.classList.toggle('light-mode', !isDarkMode); if (isDarkMode) { scene.background.setHex(0x050505); scene.fog.color.setHex(0x050505); initGrids(true); showToast("黑夜模式"); } else { scene.background.setHex(0xf0f0f0); scene.fog.color.setHex(0xf0f0f0); initGrids(false); showToast("白天模式"); } }
        function toggleVerticalPlanes() { isVerticalGridVisible = !isVerticalGridVisible; document.getElementById('vplane-btn').classList.toggle('active', isVerticalGridVisible); if (gridXY) gridXY.visible = isVerticalGridVisible; if (gridYZ) gridYZ.visible = isVerticalGridVisible; showToast(isVerticalGridVisible ? "竖向象限面：显示" : "竖向象限面：隐藏"); }
        function getBrushMaterial(i, c) { if(i==0) return new THREE.MeshLambertMaterial({color:c, emissive:c, emissiveIntensity:1.2}); if(i==1) return new THREE.MeshStandardMaterial({color:c, roughness:0.1, metalness:0.9}); if(i==2) return new THREE.MeshPhysicalMaterial({color:c, transmission:0.6, opacity:0.8, transparent:true, roughness:0, metalness:0.2}); if(i==4) return new THREE.MeshPhongMaterial({color:c, specular:0xffffff, shininess:100, opacity:0.4, transparent:true}); if(i==5||i==8) return new THREE.MeshBasicMaterial({color:c, wireframe:i==8}); if(i==6) return new THREE.MeshToonMaterial({color:c}); return new THREE.MeshLambertMaterial({color:c}); }
        function getBrushGeometry(i){ return [3,8].includes(i)?geoms.box : i==2?geoms.diamond : i==4?geoms.sphere : i==5?geoms.flat : i==6?geoms.star : geoms.sphere; }
        function initSlider() { const s=document.getElementById('size-slider'); const v=document.getElementById('size-val'); s.addEventListener('input', e=>{ baseBrushSize=e.target.value/10; v.textContent=baseBrushSize.toFixed(1); }); }
        function toggleEraser() { if(isRoam) toggleRoam(); isEraser = !isEraser; document.getElementById('eraser-btn').classList.toggle('mode-active', isEraser); document.getElementById('canvas-container').style.cursor = isEraser ? 'not-allowed' : 'default'; showToast(isEraser ? "橡皮擦" : "绘画模式"); }
        function handleEraser(e) { pointer.x = (e.clientX/window.innerWidth)*2-1; pointer.y = -(e.clientY/window.innerHeight)*2+1; raycaster.setFromCamera(pointer, camera); const intersects = raycaster.intersectObjects(strokes, true); if (intersects.length > 0) { let target = intersects[0].object; while(target.parent && target.parent !== scene) { target = target.parent; } scene.remove(target); const idx = strokes.indexOf(target); if (idx > -1) strokes.splice(idx, 1); showToast("已删除"); } }
        function toggleRoam() { isRoam = !isRoam; if(isEraser && isRoam) toggleEraser(); document.getElementById('roam-btn').classList.toggle('roam-active', isRoam); const zone = document.getElementById('joystick-zone'); const hint = document.getElementById('roam-hint'); if (isRoam) { controls.enabled = false; zone.style.display = 'block'; hint.style.display = 'block'; cameraEuler.setFromQuaternion(camera.quaternion); if (!joystickManager) { joystickManager = nipplejs.create({ zone: zone, mode: 'static', position: { left: '50%', top: '50%' }, color: 'white' }); joystickManager.on('move', (evt, data) => { moveVector.z = -data.vector.y * 0.5; moveVector.x = -data.vector.x * 0.5; }); joystickManager.on('end', () => { moveVector.set(0, 0, 0); }); } showToast("漫游模式"); } else { controls.enabled = true; controls.target.copy(camera.position).add(new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion)); zone.style.display = 'none'; hint.style.display = 'none'; moveVector.set(0,0,0); } }
        function updateRoam() { if (!isRoam) return; const d = new THREE.Vector3().copy(moveVector); d.applyEuler(new THREE.Euler(0, cameraEuler.y, 0)); camera.position.add(d); }
        function initSlots(){ for(let i=0;i<5;i++) updateSlotVisual(i); selectSlot(0); }
        function updateSlotVisual(i){ document.getElementById(`slot-${i}`).style.backgroundColor = slotColors[i]; }
        function selectSlot(i){ activeSlotIndex=i; for(let j=0;j<5;j++) document.getElementById(`slot-${j}`).classList.toggle('active', j===i); updateGlobalColor(slotColors[i]); }
        function updateGlobalColor(hex){ currentColor = new THREE.Color(hex); document.getElementById('main-color-btn').style.backgroundColor = hex; }
        function initColorGrid(){ const g = document.getElementById('color-grid'); for(let i=0;i<100;i++){ const h=Math.floor((i/100)*360), l=50+(i%2==0?10:-10); createColorCell(g, `hsl(${h}, 100%, ${l}%)`); } ['#ffffff','#cccccc','#888888','#444444','#000000'].forEach(c=>createColorCell(g,c)); }
        function createColorCell(p,c){ const d=document.createElement('div'); d.className='color-cell'; d.style.backgroundColor=c; d.onclick=()=>{ applyColorChange(d.style.backgroundColor); toggleColorGrid(); }; p.appendChild(d); }
        function toggleColorGrid(){ const g=document.getElementById('color-grid'); g.style.display=g.style.display==='grid'?'none':'grid'; }
        function applyColorChange(nc){ slotColors[activeSlotIndex]=nc; updateSlotVisual(activeSlotIndex); updateGlobalColor(nc); showToast(`槽位 ${activeSlotIndex+1} 更新`); }
        function setBrush(i){ currentBrushIndex=i; document.querySelectorAll('.brush-item').forEach((e,k)=>{ if(i===100 && k===0) e.classList.add('active'); else if(i!==100 && k===i+1) e.classList.add('active'); else e.classList.remove('active'); }); showToast("已切换画笔"); }
        function toggleAnchor(){ isAnchorMode=!isAnchorMode; document.getElementById('anchor-btn').classList.toggle('active',isAnchorMode); showToast(isAnchorMode?"吸附开启":"吸附关闭"); }
        function undo(){ if(strokes.length>0){ const s=strokes.pop(); scene.remove(s); redoStack.push(s); } }
        function redo(){ if(redoStack.length>0){ const s=redoStack.pop(); scene.add(s); strokes.push(s); } }
        function clearScene(){ if(confirm('确定清空？')){ strokes.forEach(s=>scene.remove(s)); strokes=[]; redoStack=[]; } }
        function showToast(m){ const t=document.getElementById('toast'); t.textContent=m; t.style.opacity=1; setTimeout(()=>t.style.opacity=0,1000); }
        function onWindowResize(){ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); }
        function animate(){ requestAnimationFrame(animate); controls.update(); updateRoam(); renderer.render(scene, camera); }
        function onPointerUp(){ if(isDrawing){ isDrawing=false; controls.enabled=true; if(!isRoam && currentStrokeGroup){ strokes.push(currentStrokeGroup); currentStrokeGroup=null; } document.getElementById('snap-reticle').style.display='none'; } }
        function determineDrawPlane(e){ const n=new THREE.Vector3(); camera.getWorldDirection(n); let p=new THREE.Vector3(), sn=false; if(isAnchorMode && strokes.length>0){ pointer.x=(e.clientX/window.innerWidth)*2-1; pointer.y=-(e.clientY/window.innerHeight)*2+1; raycaster.setFromCamera(pointer, camera); const i=raycaster.intersectObjects(strokes,true); if(i.length>0){ p.copy(i[0].point); sn=true; const r=document.getElementById('snap-reticle'); r.style.left=e.clientX+'px'; r.style.top=e.clientY+'px'; r.style.display='block'; showToast("深度已锁定"); } } if(!sn) p.copy(camera.position).add(n.clone().multiplyScalar(15)); drawPlane.setFromNormalAndCoplanarPoint(n,p); }
        function getDrawPoint(e){ pointer.x=(e.clientX/window.innerWidth)*2-1; pointer.y=-(e.clientY/window.innerHeight)*2+1; raycaster.setFromCamera(pointer,camera); const t=new THREE.Vector3(); raycaster.ray.intersectPlane(drawPlane,t); return t; }
        function saveProject(){ if(strokes.length==0){showToast("空画布");return;} const d=strokes.map(g=>{ const pts=[]; g.children.forEach(m=>pts.push({p:m.position.toArray(),s:m.scale.toArray(),r:m.rotation.toArray()})); return {bi:g.userData.brushIndex, c:g.userData.color, pts:pts}; }); const b=new Blob([JSON.stringify(d)],{type:'application/json'}); const u=URL.createObjectURL(b); const a=document.createElement('a'); a.href=u; a.download=`spen_art_${new Date().getTime()}.json`; a.click(); URL.revokeObjectURL(u); showToast("工程下载中"); }
        function triggerLoad(){ document.getElementById('file-input').click(); }
        function loadProjectFile(inp){ const f=inp.files[0]; if(!f)return; const r=new FileReader(); r.onload=e=>{ try{ reconstructScene(JSON.parse(e.target.result)); showToast("加载成功"); }catch(err){alert("文件错误");} }; r.readAsText(f); inp.value=''; }
        function reconstructScene(d){ strokes.forEach(s=>scene.remove(s)); strokes=[]; redoStack=[]; d.forEach(sd=>{ const g=new THREE.Group(); g.userData={brushIndex:sd.bi, color:sd.c}; scene.add(g); const mat=(sd.bi===100)?new THREE.MeshLambertMaterial({color:new THREE.Color(sd.c)}) : getBrushMaterial(sd.bi, new THREE.Color(sd.c)); const geo=(sd.bi===100)?cylinderGeo : getBrushGeometry(sd.bi); sd.pts.forEach(p=>{ const m=new THREE.Mesh(geo,mat); m.position.fromArray(p.p); m.scale.fromArray(p.s); m.rotation.fromArray(p.r); g.add(m); }); strokes.push(g); }); }
        function saveImage(){ renderer.render(scene,camera); const l=document.createElement('a'); l.download=`spen_snap_${new Date().getTime()}.png`; l.href=renderer.domElement.toDataURL('image/png'); l.click(); showToast("截图已保存"); }
    </script>
</body>
</html>


